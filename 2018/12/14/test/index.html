<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>从jvm虚拟机角度看Java多态 -&gt;（重写override）的实现原理 | 楚轩</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="工具与环境: Windows 7 x64企业版 Cygwin x64 jdk1.8.0_162 openjdk-8u40-src-b25-10_feb_2015 Vs2010 professional 0x00: Java多态简单介绍1.多态的概念：JAVA类被jvm加载运行时根据调用该方法的对像实例的类型来决定选择调用哪个方法则被称为运行时多态。也叫动态绑定：是指在执行期间判断所引用对象实例的实">
<meta property="og:type" content="article">
<meta property="og:title" content="从jvm虚拟机角度看Java多态 -&gt;（重写override）的实现原理">
<meta property="og:url" content="http://yoursite.com/2018/12/14/test/index.html">
<meta property="og:site_name" content="楚轩">
<meta property="og:description" content="工具与环境: Windows 7 x64企业版 Cygwin x64 jdk1.8.0_162 openjdk-8u40-src-b25-10_feb_2015 Vs2010 professional 0x00: Java多态简单介绍1.多态的概念：JAVA类被jvm加载运行时根据调用该方法的对像实例的类型来决定选择调用哪个方法则被称为运行时多态。也叫动态绑定：是指在执行期间判断所引用对象实例的实">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-1.png">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-2.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-3.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-4.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-5.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-6.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-7.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-8.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-9.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/14/test/1-10.jpg">
<meta property="og:updated_time" content="2018-12-14T07:44:18.108Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从jvm虚拟机角度看Java多态 -&gt;（重写override）的实现原理">
<meta name="twitter:description" content="工具与环境: Windows 7 x64企业版 Cygwin x64 jdk1.8.0_162 openjdk-8u40-src-b25-10_feb_2015 Vs2010 professional 0x00: Java多态简单介绍1.多态的概念：JAVA类被jvm加载运行时根据调用该方法的对像实例的类型来决定选择调用哪个方法则被称为运行时多态。也叫动态绑定：是指在执行期间判断所引用对象实例的实">
<meta name="twitter:image" content="http://yoursite.com/2018/12/14/test/1-1.png">
  
    <link rel="alternate" href="/atom.xml" title="楚轩" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">楚轩</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-test" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/14/test/" class="article-date">
  <time datetime="2018-12-14T03:38:01.164Z" itemprop="datePublished">2018-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      从jvm虚拟机角度看Java多态 -&gt;（重写override）的实现原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工具与环境:</p>
<p>Windows 7 x64企业版</p>
<p>Cygwin x64</p>
<p>jdk1.8.0_162</p>
<p>openjdk-8u40-src-b25-10_feb_2015</p>
<p>Vs2010 professional</p>
<h2 id="0x00-Java多态简单介绍"><a href="#0x00-Java多态简单介绍" class="headerlink" title="0x00: Java多态简单介绍"></a>0x00: Java多态简单介绍</h2><h3 id="1-多态的概念："><a href="#1-多态的概念：" class="headerlink" title="1.多态的概念："></a>1.多态的概念：</h3><p>JAVA类被jvm加载运行时根据调用该方法的对像实例的类型来决定选择调用哪个方法则被称为运行时多态。也叫动态绑定：是指在执行期间判断所引用对象实例的实际类型，根据其实际的类型调用其相应的方法。</p>
<p>2.多态的优点：</p>
<p>a.可替换性: 多态对已存在代码具有可替换性。</p>
<p>b.可扩充性: 多态对代码具有可扩充性。<br>c.灵活性: 它在应用中体现了灵活多样的操作，提高了使用效率。<br>d.简化性: 多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>3.示例代码(以下分析基于该代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"is animal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">        run(animal);</span><br><span class="line">        animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        run(animal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"is Dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"is Cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译: javac Animal.java生成.class文件。</p>
<p><img src="/2018/12/14/test/1-1.png" alt="运行后如下"></p>
<p>4.上面示例程序中定义了类 Animal ，同时定义了 2 个子类 Dog 和 Cat，这 2 个子类都重写了基类中的 say（）方法 。 在 main（）函数中，将 animal 实例引用分别指向 Dog 和 Cat 的实例， 并分别调用 run(Animal）方法。 在本示例中，当在 Animal.run(Animal）方法中执行 animal.say（）时， 因为</p>
<p>在编译期并不知道 animal 这个引用到底指向哪个实例对象，所以编译期无法进行绑定，必须等到运行期才能确切知道最终调用哪个子类的 say（）方法，这便是动态绑定，也即晚绑定，这是 Java语言以及绝大多数面向对象语言的动态机制最直接的体现。</p>
<h3 id="0x01-C＋＋的多态与vftable分析"><a href="#0x01-C＋＋的多态与vftable分析" class="headerlink" title="0x01: C＋＋的多态与vftable分析"></a>0x01: C＋＋的多态与vftable分析</h3><ol>
<li><p>在分析JVM多态的实现原理之前，我们先一起看看 C++中虚方法表的实现机制，这两者有很紧密的联系，有助于我们理解JVM中的多态机制。</p>
</li>
<li><p>示例代码:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cpuls</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cpuls cplus;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 C＋＋示例很简单，类中包含一个 int 类型的变量和一个 run（）方法，在 main函数中定义一个Cpuls对像。通过vs 调试时看内存情况，没有虚函数时对象的内存表现如下图：</p>
<p><img src="/2018/12/14/test/1-2.jpg" alt="内存表现如下图"></p>
<p>由于 CPLUS 类中仅包含 l 个 int 类型的变量 ，因此观察结果中的 cplus 实例内存地址，只有变量 x 。</p>
<p>现在将 C＋＋类中的 run方法修改一下，变成虚方法，在观察对象的内存表现：</p>
<p><img src="/2018/12/14/test/1-3.jpg" alt=""></p>
<p>注意看，现在的值变了，cplus 实例首地址不是其变量x了，而是一个vfable，这就是虚表，并且vfable中存放加了virtual关键字的虚函数func函数的地址，这是因为当 C＋＋类中出现虚方法时，表示该方法拥有多态性，此时会根据类型指针所指向的实际对象而在运行期调用不同的方法。</p>
<p>C＋＋为了实现多态，就在 C＋＋类实例对象中嵌入虚函数表vfable ，通过虚函数表来实现运行期的方法分派 。 C＋＋中所谓虚函数表，其实就是一个普通的表，表中存储的是方法指针， 方法指针会指向目标方法的内存地址,所以虚函数表就是一堆指针的集合而已。</p>
<p>详细的可以看这位大牛的分析<a href="https://bbs.pediy.com/thread-221160.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-221160.htm</a></p>
<h3 id="0x02-JVM中函数重写实现机制"><a href="#0x02-JVM中函数重写实现机制" class="headerlink" title="0x02: JVM中函数重写实现机制"></a>0x02: JVM中函数重写实现机制</h3><ol>
<li>Java中的多态在语义上与上面分析C++的原理是相同的，Java在JVM中的多态机制并没有跳出这个圈也采用了 vftable 来实现动态绑定。</li>
</ol>
<p>JVM 的 vftable 机制与 C＋＋的 vftable机制之间的不同点在于， C＋＋的 vftable 在编译期间便由编译器完成分析和模型构建，而 JVM 的 vftable 则在 JVM 运行期类被加载时进行动态构建。下面通过hotspot源码来分析JVM中函数重写机制。</p>
<ol start="2">
<li>当我们通过java 执行class文件时，JVM 会在第一次加载类时调用classFileParser.cpp::parseClassFile()函数对 Java class 文件字节码进行解析，在parseClassFile()函数中会调用parse_methods()函数解析class文件类中的方法,parse_methods()函数执行完之后 ，会继续调用 klassVtable::compute_vtable_size_and_num_mirandas()函数，计算当前类的vtable大小,下面看看该方法实现的主要逻辑：</li>
</ol>
<p>判断是否有虚函数，如果有就将个数增加, src\share\vm\oops\klassVtable.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> klassVtable::compute_vtable_size_and_num_mirandas(</span><br><span class="line">    <span class="keyword">int</span>* vtable_length_ret, <span class="keyword">int</span>* num_new_mirandas,</span><br><span class="line">    GrowableArray&lt;Method*&gt;* all_mirandas, Klass* super,</span><br><span class="line">    Array&lt;Method*&gt;* methods, AccessFlags class_flags,</span><br><span class="line">    Handle classloader, Symbol* classname, Array&lt;Klass*&gt;* local_interfaces,</span><br><span class="line">    TRAPS) &#123;</span><br><span class="line">  No_Safepoint_Verifier nsv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up default result values</span></span><br><span class="line">  <span class="keyword">int</span> vtable_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start off with super's vtable length</span></span><br><span class="line">  InstanceKlass* sk = (InstanceKlass*)super;</span><br><span class="line">  <span class="comment">//获取父类 vtable 的大小，并将当前类的 vtable 的大小设置为父类 vtable 的大小。</span></span><br><span class="line">  vtable_length = super == <span class="literal">NULL</span> ? <span class="number">0</span> : sk-&gt;vtable_length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// go thru each method in the methods table to see if it needs a new entry</span></span><br><span class="line">  <span class="keyword">int</span> len = methods-&gt;length();<span class="comment">//方法个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    assert(methods-&gt;at(i)-&gt;is_method(), <span class="string">"must be a Method*"</span>);</span><br><span class="line">    <span class="function">methodHandle <span class="title">mh</span><span class="params">(THREAD, methods-&gt;at(i))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*循环遍历当前 Java 类的每一个方法 ，调用 needs_new_vtable_entry()函数进行判断，</span></span><br><span class="line"><span class="comment">    如果判断的结果是 true ，则将 vtable 的大小增 1 */</span></span><br><span class="line">    <span class="keyword">if</span> (needs_new_vtable_entry(mh, super, classloader, classname, class_flags, THREAD)) &#123;</span><br><span class="line">      vtable_length += vtableEntry::size(); <span class="comment">// we need a new entry</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  GrowableArray&lt;Method*&gt; new_mirandas(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">// compute the number of mirandas methods that must be added to the end</span></span><br><span class="line">  get_mirandas(&amp;new_mirandas, all_mirandas, super, methods, <span class="literal">NULL</span>, local_interfaces);</span><br><span class="line">  *num_new_mirandas = new_mirandas.length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Interfaces do not need interface methods in their vtables</span></span><br><span class="line">  <span class="comment">// This includes miranda methods and during later processing, default methods</span></span><br><span class="line">  <span class="keyword">if</span> (!class_flags.is_interface()) &#123;</span><br><span class="line">    vtable_length += *num_new_mirandas * vtableEntry::size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Universe::is_bootstrapping() &amp;&amp; vtable_length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// array classes don't have their superclass set correctly during</span></span><br><span class="line">    <span class="comment">// bootstrapping</span></span><br><span class="line">    vtable_length = Universe::base_vtable_size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (super == <span class="literal">NULL</span> &amp;&amp; !Universe::is_bootstrapping() &amp;&amp;</span><br><span class="line">      vtable_length != Universe::base_vtable_size()) &#123;</span><br><span class="line">    <span class="comment">// Someone is attempting to redefine java.lang.Object incorrectly.  The</span></span><br><span class="line">    <span class="comment">// only way this should happen is from</span></span><br><span class="line">    <span class="comment">// SystemDictionary::resolve_from_stream(), which will detect this later</span></span><br><span class="line">    <span class="comment">// and throw a security exception.  So don't assert here to let</span></span><br><span class="line">    <span class="comment">// the exception occur.</span></span><br><span class="line">    vtable_length = Universe::base_vtable_size();</span><br><span class="line">  &#125;</span><br><span class="line">  assert(super != <span class="literal">NULL</span> || vtable_length == Universe::base_vtable_size(),</span><br><span class="line">         <span class="string">"bad vtable size for class Object"</span>);</span><br><span class="line">  assert(vtable_length % vtableEntry::size() == <span class="number">0</span>, <span class="string">"bad vtable length"</span>);</span><br><span class="line">  assert(vtable_length &gt;= Universe::base_vtable_size(), <span class="string">"vtable too small"</span>);</span><br><span class="line"></span><br><span class="line">  *vtable_length_ret = vtable_length;<span class="comment">//返回虚方法个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码计算 vftable 个数的思路主要分为两步 ：</p>
<p>a:获取父类 vftable 的个数，并将当前类的 vftable 的个数设置为父类 vftable 的个数。</p>
<p>b:循环遍历当前 Java 类的每一个方法 ，调用 needs_new_vtable_entry()函数进行判断，如果判断的结果是 true ，则将 vftable 的个数增 1 。</p>
<ol start="3">
<li>现在看needs_new_vtable_entry()函数是如何判断虚函数的，判断条件是什么？</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">bool klassVtable::needs_new_vtable_entry(methodHandle target_method,</span><br><span class="line">                                         Klass* super,</span><br><span class="line">                                         Handle classloader,</span><br><span class="line">                                         Symbol* classname,</span><br><span class="line">                                         AccessFlags class_flags,</span><br><span class="line">                                         TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">/*如果 Java 方法被 final、static修饰，或者 Java 类被 final 修饰，或者 Java 方法是构造</span><br><span class="line"> 函数&lt;init&gt;，则返回 <span class="literal">false</span> */</span><br><span class="line">  <span class="keyword">if</span> (class_flags.is_interface()) &#123;</span><br><span class="line">    // Interfaces <span class="keyword">do</span> not use vtables, except <span class="keyword">for</span> java.lang.Object methods,</span><br><span class="line">    // so there is no point to assigning</span><br><span class="line">    // a vtable index to any of their <span class="built_in">local</span> methods.  If we refrain from doing this,</span><br><span class="line">    // we can use Method::_vtable_index to hold the itable index</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target_method-&gt;is_final_method(class_flags) ||</span><br><span class="line">      // a final method never needs a new entry; final methods can be statically</span><br><span class="line">      // resolved and they have to be present <span class="keyword">in</span> the vtable only <span class="keyword">if</span> they override</span><br><span class="line">      // a super<span class="string">'s method, in which case they re-use its entry</span></span><br><span class="line"><span class="string">      (target_method()-&gt;is_static()) ||</span></span><br><span class="line"><span class="string">      // static methods don'</span>t need to be <span class="keyword">in</span> vtable</span><br><span class="line">      (target_method()-&gt;name() ==  vmSymbols::object_initializer_name())</span><br><span class="line">      // &lt;init&gt; is never called dynamically-bound</span><br><span class="line">      ) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Concrete interface methods <span class="keyword">do</span> not need new entries, they override</span><br><span class="line">  // abstract method entries using default inheritance rules</span><br><span class="line">  <span class="keyword">if</span> (target_method()-&gt;method_holder() != NULL &amp;&amp;</span><br><span class="line">      target_method()-&gt;method_holder()-&gt;is_interface()  &amp;&amp;</span><br><span class="line">      !target_method()-&gt;is_abstract() ) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // we need a new entry <span class="keyword">if</span> there is no superclass</span><br><span class="line">  <span class="keyword">if</span> (super == NULL) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // private methods <span class="keyword">in</span> classes always have a new entry <span class="keyword">in</span> the vtable</span><br><span class="line">  // specification interpretation since classic has</span><br><span class="line">  // private methods not overriding</span><br><span class="line">  // JDK8 adds private  methods <span class="keyword">in</span> interfaces <span class="built_in">which</span> require invokespecial</span><br><span class="line">  <span class="keyword">if</span> (target_method()-&gt;is_private()) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Package private methods always need a new entry to root their own</span><br><span class="line">  // overriding. This allows transitive overriding to work.</span><br><span class="line">  <span class="keyword">if</span> (target_method()-&gt;is_package_private()) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // search through the super class hierarchy to see <span class="keyword">if</span> we need</span><br><span class="line">  // a new entry</span><br><span class="line">  /*遍历父类中同名 、签名也完全相同的方法，如果父类方法的访问权限是 public 或者 protected,</span><br><span class="line">  并且没有 static 或 private 修饰，则说明子类重写了父类的方法，此时返回 <span class="literal">false</span>*/</span><br><span class="line">  ResourceMark rm;</span><br><span class="line">  Symbol* name = target_method()-&gt;name();//当前方法名</span><br><span class="line">  Symbol* signature = target_method()-&gt;signature();</span><br><span class="line">  Klass* k = super;</span><br><span class="line">  Method* super_method = NULL;</span><br><span class="line">  InstanceKlass *holder = NULL;</span><br><span class="line">  Method* recheck_method =  NULL;</span><br><span class="line">  <span class="keyword">while</span> (k != NULL) &#123;</span><br><span class="line"></span><br><span class="line">      //<span class="built_in">test</span></span><br><span class="line">      //<span class="built_in">printf</span>(<span class="string">"class name = %s\n"</span>,classname-&gt;base());</span><br><span class="line">    // lookup through the hierarchy <span class="keyword">for</span> a method with matching name and sign.</span><br><span class="line">    super_method = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);//判断当前方法名与签名在父类中是否吸同名同签名的方法</span><br><span class="line">    <span class="keyword">if</span> (super_method == NULL) &#123;</span><br><span class="line">      <span class="built_in">break</span>; // we still have to search <span class="keyword">for</span> a matching miranda method</span><br><span class="line">    &#125;</span><br><span class="line">    // get the class holding the matching method</span><br><span class="line">    // make sure you use that class <span class="keyword">for</span> is_override</span><br><span class="line">    InstanceKlass* superk = super_method-&gt;method_holder();</span><br><span class="line">    // we want only instance method matches</span><br><span class="line">    // pretend private methods are not <span class="keyword">in</span> the super vtable</span><br><span class="line">    // since we <span class="keyword">do</span> override around them: e.g. a.m pub/b.m private/c.m pub,</span><br><span class="line">    // ignore private, c.m pub does override a.m pub</span><br><span class="line">    // For classes that were not javac<span class="string">'d together, we also do transitive overriding around</span></span><br><span class="line"><span class="string">    // methods that have less accessibility</span></span><br><span class="line"><span class="string">    if ((!super_method-&gt;is_static()) &amp;&amp;</span></span><br><span class="line"><span class="string">       (!super_method-&gt;is_private())) &#123;</span></span><br><span class="line"><span class="string">      if (superk-&gt;is_override(super_method, classloader, classname, THREAD)) &#123;//如果父类方法的访问权限是public或者protected,并且没有static或private修饰，则说明子类重写了父类的方法，此时返回false</span></span><br><span class="line"><span class="string">        return false;</span></span><br><span class="line"><span class="string">      // else keep looking for transitive overrides</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Start with lookup result and continue to search up</span></span><br><span class="line"><span class="string">    k = superk-&gt;super(); // haven'</span>t found an override match yet; <span class="built_in">continue</span> to look</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // <span class="keyword">if</span> the target method is public or protected it may have a matching</span><br><span class="line">  // miranda method <span class="keyword">in</span> the super, whose entry it should re-use.</span><br><span class="line">  // Actually, to handle cases that javac would not generate, we need</span><br><span class="line">  // this check <span class="keyword">for</span> all access permissions.</span><br><span class="line">  InstanceKlass *sk = InstanceKlass::cast(super);</span><br><span class="line">  <span class="keyword">if</span> (sk-&gt;has_miranda_methods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;lookup_method_in_all_interfaces(name, signature, Klass::normal) != NULL) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">false</span>;  // found a matching miranda; we <span class="keyword">do</span> not need a new entry</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>; // found no match; we need a new entry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要判断Java 类在运行期进行动态绑定的方法，一定会被声明为 public 或者 protected 的，并且没有 static 和 final 修饰，且 Java 类上也没有 final 修饰 。</p>
<ol start="4">
<li>当class文件被分析完成后就要创建一个内存中的instanceKlass对象来存放class信息，这时就要用到上面分析的虚表个数了vtable_size。该变量值将在创建类所对应的instanceKlass对象时被保存到该对象中的一vtable_Ien 字段中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We can now create the basic Klass* for this klass</span></span><br><span class="line">    _klass = InstanceKlass::allocate_instance_klass(loader_data,</span><br><span class="line">                                                    vtable_size,</span><br><span class="line">                                                    itable_size,</span><br><span class="line">                                                    info.static_field_size,</span><br><span class="line">                                                    total_oop_map_size2,</span><br><span class="line">                                                    rt,</span><br><span class="line">                                                    access_flags,</span><br><span class="line">                                                    name,</span><br><span class="line">                                                    super_klass(),</span><br><span class="line">                                                    !host_klass.is_null(),</span><br><span class="line">                                                    CHECK_(nullHandle));</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>当class分析并将相关的信息存放在instanceKlass实例对像中后就准备要执行函数了， 在分析重写之前我们来看看vtable在什么地方。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\src\share\vm\oops\instanceKlass.cpp</span><br><span class="line">link_class-&gt;link_class_impl</span><br><span class="line"><span class="comment">//初始化虚表</span></span><br><span class="line">      <span class="comment">// Initialize the vtable and interface table after</span></span><br><span class="line">      <span class="comment">// methods have been rewritten since rewrite may</span></span><br><span class="line">      <span class="comment">// fabricate new Method*s.</span></span><br><span class="line">      <span class="comment">// also does loader constraint checking</span></span><br><span class="line">      <span class="keyword">if</span> (!this_oop()-&gt;is_shared()) &#123;</span><br><span class="line">        <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">        this_oop-&gt;vtable()-&gt;initialize_vtable(<span class="literal">true</span>, CHECK_false);<span class="comment">//初始化虚表</span></span><br><span class="line">        this_oop-&gt;itable()-&gt;initialize_itable(<span class="literal">true</span>, CHECK_false);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>每一个 Java 类在 JVM 内部都有一个对应的instanceKlass, vtable 就被分配在这个 oop 内存区域的后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> InstanceKlass* klassVtable::ik() <span class="keyword">const</span> &#123;</span><br><span class="line">  Klass* k = _klass();</span><br><span class="line">  assert(k-&gt;oop_is_instance(), <span class="string">"not an InstanceKlass"</span>);</span><br><span class="line">  <span class="keyword">return</span> (InstanceKlass*)k;</span><br><span class="line">&#125;</span><br><span class="line">klassVtable(KlassHandle h_klass, <span class="keyword">void</span>* base, <span class="keyword">int</span> length) : _klass(h_klass) &#123;</span><br><span class="line">    _tableOffset = (address)base - (address)h_klass(); _length = length;<span class="comment">//虚表偏移(InstanceKlass对像大小)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚表地址</span></span><br><span class="line"><span class="function">vtableEntry* <span class="title">table</span><span class="params">()</span> <span class="keyword">const</span>      </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (vtableEntry*)(address(_klass()) + _tableOffset); <span class="comment">//InstanceKlass对像基址加上InstanceKlass对像大小</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>instanceKlass大小在 windows64系统的大小为0x1b8如下，后面用hsdb查看vtable时会用到。</p>
<p><img src="/2018/12/14/test/1-4.jpg" alt=""></p>
<ol start="6">
<li>方法的重写主要在该函数中:</li>
</ol>
<p>klassVtable::initialize_vtable(bool checkconstraints, TRAPS)函数主要逻辑：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">int klassVtable::initialize_from_super(KlassHandle super) &#123;</span><br><span class="line">  <span class="keyword">if</span> (super.is_null()) &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // copy methods from superKlass</span><br><span class="line">    // can<span class="string">'t inherit from array class, so must be InstanceKlass</span></span><br><span class="line"><span class="string">    assert(super-&gt;oop_is_instance(), "must be instance klass");</span></span><br><span class="line"><span class="string">    InstanceKlass* sk = (InstanceKlass*)super();</span></span><br><span class="line"><span class="string">    klassVtable* superVtable = sk-&gt;vtable();</span></span><br><span class="line"><span class="string">    assert(superVtable-&gt;length() &lt;= _length, "vtable too short");</span></span><br><span class="line"><span class="string">#ifdef ASSERT</span></span><br><span class="line"><span class="string">    superVtable-&gt;verify(tty, true);</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">    superVtable-&gt;copy_vtable_to(table());</span></span><br><span class="line"><span class="string">#ifndef PRODUCT</span></span><br><span class="line"><span class="string">    if (PrintVtables &amp;&amp; Verbose) &#123;</span></span><br><span class="line"><span class="string">      ResourceMark rm;</span></span><br><span class="line"><span class="string">      tty-&gt;print_cr("copy vtable from %s to %s size %d", sk-&gt;internal_name(), klass()-&gt;internal_name(), _length);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string">    return superVtable-&gt;length();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//</span></span><br><span class="line"><span class="string">// Revised lookup semantics   introduced 1.3 (Kestrel beta)</span></span><br><span class="line"><span class="string">void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // Note:  Arrays can have intermediate array supers.  Use java_super to skip them.</span></span><br><span class="line"><span class="string">  KlassHandle super (THREAD, klass()-&gt;java_super());</span></span><br><span class="line"><span class="string">  int nofNewEntries = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (PrintVtables &amp;&amp; !klass()-&gt;oop_is_array()) &#123;</span></span><br><span class="line"><span class="string">    ResourceMark rm(THREAD);</span></span><br><span class="line"><span class="string">    tty-&gt;print_cr("Initializing: %s", _klass-&gt;name()-&gt;as_C_string());</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#ifdef ASSERT</span></span><br><span class="line"><span class="string">  oop* end_of_obj = (oop*)_klass() + _klass()-&gt;size();</span></span><br><span class="line"><span class="string">  oop* end_of_vtable = (oop*)&amp;table()[_length];</span></span><br><span class="line"><span class="string">  assert(end_of_vtable &lt;= end_of_obj, "vtable extends beyond end");</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if (Universe::is_bootstrapping()) &#123;</span></span><br><span class="line"><span class="string">    // just clear everything</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; _length; i++) table()[i].clear();</span></span><br><span class="line"><span class="string">    return;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  int super_vtable_len = initialize_from_super(super);</span></span><br><span class="line"><span class="string">  if (klass()-&gt;oop_is_array()) &#123;</span></span><br><span class="line"><span class="string">    assert(super_vtable_len == _length, "arrays shouldn'</span>t introduce new methods<span class="string">");</span></span><br><span class="line"><span class="string">  &#125; else &#123;</span></span><br><span class="line"><span class="string">    assert(_klass-&gt;oop_is_instance(), "</span>must be InstanceKlass<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Array&lt;Method*&gt;* methods = ik()-&gt;methods();</span></span><br><span class="line"><span class="string">    int len = methods-&gt;length();</span></span><br><span class="line"><span class="string">    int initialized = super_vtable_len;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Check each of this class's methods against super;</span></span><br><span class="line"><span class="string">    // if override, replace in copy of super vtable, otherwise append to end</span></span><br><span class="line"><span class="string">    for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="string">      // update_inherited_vtable can stop for gc - ensure using handles</span></span><br><span class="line"><span class="string">      HandleMark hm(THREAD);</span></span><br><span class="line"><span class="string">      assert(methods-&gt;at(i)-&gt;is_method(), "</span>must be a Method*<span class="string">");</span></span><br><span class="line"><span class="string">      methodHandle mh(THREAD, methods-&gt;at(i));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      /*判断是否重写或有虚函数,如果overwrite函数,(方法名字，参数签名 完全一样)，</span></span><br><span class="line"><span class="string">      也就是替换虚拟表相同顺序的内容*/</span></span><br><span class="line"><span class="string">      bool needs_new_entry = update_inherited_vtable(ik(), mh, super_vtable_len, -1, checkconstraints, CHECK);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      //needs_new_entry ==true如果符合虚拟函数则顺序添加到虚拟表尾部</span></span><br><span class="line"><span class="string">      if (needs_new_entry) &#123;</span></span><br><span class="line"><span class="string">        put_method_at(mh(), initialized);//存放函数</span></span><br><span class="line"><span class="string">        mh()-&gt;set_vtable_index(initialized); // set primary vtable index</span></span><br><span class="line"><span class="string">        initialized++;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // update vtable with default_methods</span></span><br><span class="line"><span class="string">    Array&lt;Method*&gt;* default_methods = ik()-&gt;default_methods();</span></span><br><span class="line"><span class="string">    if (default_methods != NULL) &#123;</span></span><br><span class="line"><span class="string">      len = default_methods-&gt;length();</span></span><br><span class="line"><span class="string">      if (len &gt; 0) &#123;</span></span><br><span class="line"><span class="string">        Array&lt;int&gt;* def_vtable_indices = NULL;</span></span><br><span class="line"><span class="string">        if ((def_vtable_indices = ik()-&gt;default_vtable_indices()) == NULL) &#123;</span></span><br><span class="line"><span class="string">          def_vtable_indices = ik()-&gt;create_new_default_vtable_indices(len, CHECK);</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">          assert(def_vtable_indices-&gt;length() == len, "</span>reinit vtable len?<span class="string">");</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="string">          HandleMark hm(THREAD);</span></span><br><span class="line"><span class="string">          assert(default_methods-&gt;at(i)-&gt;is_method(), "</span>must be a Method*<span class="string">");</span></span><br><span class="line"><span class="string">          methodHandle mh(THREAD, default_methods-&gt;at(i));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          bool needs_new_entry = update_inherited_vtable(ik(), mh, super_vtable_len, i, checkconstraints, CHECK);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          // needs new entry</span></span><br><span class="line"><span class="string">          if (needs_new_entry) &#123;</span></span><br><span class="line"><span class="string">            put_method_at(mh(), initialized);</span></span><br><span class="line"><span class="string">            def_vtable_indices-&gt;at_put(i, initialized); //set vtable index</span></span><br><span class="line"><span class="string">            initialized++;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // add miranda methods; it will also return the updated initialized</span></span><br><span class="line"><span class="string">    // Interfaces do not need interface methods in their vtables</span></span><br><span class="line"><span class="string">    // This includes miranda methods and during later processing, default methods</span></span><br><span class="line"><span class="string">    if (!ik()-&gt;is_interface()) &#123;</span></span><br><span class="line"><span class="string">      initialized = fill_in_mirandas(initialized);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // In class hierarchies where the accessibility is not increasing (i.e., going from private -&gt;</span></span><br><span class="line"><span class="string">    // package_private -&gt; public/protected), the vtable might actually be smaller than our initial</span></span><br><span class="line"><span class="string">    // calculation.</span></span><br><span class="line"><span class="string">    assert(initialized &lt;= _length, "</span>vtable initialization failed<span class="string">");</span></span><br><span class="line"><span class="string">    for(;initialized &lt; _length; initialized++) &#123;</span></span><br><span class="line"><span class="string">      put_method_at(NULL, initialized);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    NOT_PRODUCT(verify(tty, true));</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上代码逻辑主要是调用update_inherited_vtable函数判断子类中是否有与父类中方法名签名完全相同的方法，若该方法是对父类方法的重写,就调用klassVtable::put_method_at(Method<em> m, int index)函数进行重写操作，更新父类 vtable 表中指向父类被重写的方法的指针，使其指向子类中该方法的内存地址。 若该方法并不是对父类方法的重写，则会调用klassVtable::put_method_at(Method</em> m, int index)函数向该 Java 类的 vtable 中插入一个新的指针元素，使其指向该方法的内存地址,增加一个新的虚函数地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> klassVtable::update_inherited_vtable(InstanceKlass* klass, methodHandle target_method,</span><br><span class="line">                                          <span class="keyword">int</span> super_vtable_len, <span class="keyword">int</span> default_index,</span><br><span class="line">                                          <span class="keyword">bool</span> checkconstraints, TRAPS) &#123;</span><br><span class="line">  ResourceMark rm;</span><br><span class="line">  <span class="keyword">bool</span> allocate_new = <span class="literal">true</span>;</span><br><span class="line">  assert(klass-&gt;oop_is_instance(), <span class="string">"must be InstanceKlass"</span>);</span><br><span class="line"></span><br><span class="line">  Array&lt;<span class="keyword">int</span>&gt;* def_vtable_indices = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">bool</span> is_default = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// default methods are concrete methods in superinterfaces which are added to the vtable</span></span><br><span class="line">  <span class="comment">// with their real method_holder</span></span><br><span class="line">  <span class="comment">// Since vtable and itable indices share the same storage, don't touch</span></span><br><span class="line">  <span class="comment">// the default method's real vtable/itable index</span></span><br><span class="line">  <span class="comment">// default_vtable_indices stores the vtable value relative to this inheritor</span></span><br><span class="line">  <span class="keyword">if</span> (default_index &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">    is_default = <span class="literal">true</span>;</span><br><span class="line">    def_vtable_indices = klass-&gt;default_vtable_indices();</span><br><span class="line">    assert(def_vtable_indices != <span class="literal">NULL</span>, <span class="string">"def vtable alloc?"</span>);</span><br><span class="line">    assert(default_index &lt;= def_vtable_indices-&gt;length(), <span class="string">"def vtable len?"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(klass == target_method()-&gt;method_holder(), <span class="string">"caller resp."</span>);</span><br><span class="line">    <span class="comment">// Initialize the method's vtable index to "nonvirtual".</span></span><br><span class="line">    <span class="comment">// If we allocate a vtable entry, we will update it to a non-negative number.</span></span><br><span class="line">    target_method()-&gt;set_vtable_index(Method::nonvirtual_vtable_index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Static and &lt;init&gt; methods are never in</span></span><br><span class="line">  <span class="keyword">if</span> (target_method()-&gt;is_static() || target_method()-&gt;name() ==  vmSymbols::object_initializer_name()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target_method-&gt;is_final_method(klass-&gt;access_flags())) &#123;</span><br><span class="line">    <span class="comment">// a final method never needs a new entry; final methods can be statically</span></span><br><span class="line">    <span class="comment">// resolved and they have to be present in the vtable only if they override</span></span><br><span class="line">    <span class="comment">// a super's method, in which case they re-use its entry</span></span><br><span class="line">    allocate_new = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (klass-&gt;is_interface()) &#123;</span><br><span class="line">    allocate_new = <span class="literal">false</span>;  <span class="comment">// see note below in needs_new_vtable_entry</span></span><br><span class="line">    <span class="comment">// An interface never allocates new vtable slots, only inherits old ones.</span></span><br><span class="line">    <span class="comment">// This method will either be assigned its own itable index later,</span></span><br><span class="line">    <span class="comment">// or be assigned an inherited vtable index in the loop below.</span></span><br><span class="line">    <span class="comment">// default methods inherited by classes store their vtable indices</span></span><br><span class="line">    <span class="comment">// in the inheritor's default_vtable_indices</span></span><br><span class="line">    <span class="comment">// default methods inherited by interfaces may already have a</span></span><br><span class="line">    <span class="comment">// valid itable index, if so, don't change it</span></span><br><span class="line">    <span class="comment">// overpass methods in an interface will be assigned an itable index later</span></span><br><span class="line">    <span class="comment">// by an inheriting class</span></span><br><span class="line">    <span class="keyword">if</span> (!is_default || !target_method()-&gt;has_itable_index()) &#123;</span><br><span class="line">      target_method()-&gt;set_vtable_index(Method::pending_itable_index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we need a new entry if there is no superclass</span></span><br><span class="line">  <span class="keyword">if</span> (klass-&gt;super() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> allocate_new;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// private methods in classes always have a new entry in the vtable</span></span><br><span class="line">  <span class="comment">// specification interpretation since classic has</span></span><br><span class="line">  <span class="comment">// private methods not overriding</span></span><br><span class="line">  <span class="comment">// JDK8 adds private methods in interfaces which require invokespecial</span></span><br><span class="line">  <span class="keyword">if</span> (target_method()-&gt;is_private()) &#123;</span><br><span class="line">    <span class="keyword">return</span> allocate_new;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// search through the vtable and update overridden entries</span></span><br><span class="line">  <span class="comment">// Since check_signature_loaders acquires SystemDictionary_lock</span></span><br><span class="line">  <span class="comment">// which can block for gc, once we are in this loop, use handles</span></span><br><span class="line">  <span class="comment">// For classfiles built with &gt;= jdk7, we now look for transitive overrides</span></span><br><span class="line"></span><br><span class="line">  Symbol* name = target_method()-&gt;name();</span><br><span class="line">  Symbol* signature = target_method()-&gt;signature();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* m_method_name = <span class="literal">NULL</span>;</span><br><span class="line">  m_method_name = name-&gt;as_C_string();</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(m_method_name, <span class="string">"say"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"target_method name %s\n"</span>,m_method_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">KlassHandle <span class="title">target_klass</span><span class="params">(THREAD, target_method()-&gt;method_holder())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (target_klass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    target_klass = _klass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Handle <span class="title">target_loader</span><span class="params">(THREAD, target_klass-&gt;class_loader())</span></span>;</span><br><span class="line"></span><br><span class="line">  Symbol* target_classname = target_klass-&gt;name();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* class_name = target_classname-&gt;as_C_string();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可以在这里判断加载目标类时断点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(class_name, <span class="string">"Dog"</span>) || <span class="number">0</span> == <span class="built_in">strcmp</span>(class_name, <span class="string">"Animal"</span>) || <span class="number">0</span> == <span class="built_in">strcmp</span>(class_name, <span class="string">"Cat"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"update_inherited_vtable %s\n"</span>,class_name);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; super_vtable_len; i++) &#123;</span><br><span class="line">    Method* super_method = method_at(i);</span><br><span class="line">    <span class="comment">// Check if method name matches</span></span><br><span class="line">    m_method_name = super_method-&gt;name()-&gt;as_C_string();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"super_method name %s\n"</span>,m_method_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断方法名签名是否与父类中相同</span></span><br><span class="line">    <span class="keyword">if</span> (super_method-&gt;name() == name &amp;&amp; super_method-&gt;signature() == signature) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// get super_klass for method_holder for the found method</span></span><br><span class="line">      InstanceKlass* super_klass =  super_method-&gt;method_holder();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否为重写</span></span><br><span class="line">      <span class="keyword">if</span> (is_default</span><br><span class="line">          || ((super_klass-&gt;is_override(super_method, target_loader, target_classname, THREAD))</span><br><span class="line">          || ((klass-&gt;major_version() &gt;= VTABLE_TRANSITIVE_OVERRIDE_VERSION)</span><br><span class="line">          &amp;&amp; ((super_klass = find_transitive_override(super_klass,</span><br><span class="line">                             target_method, i, target_loader,</span><br><span class="line">                             target_classname, THREAD))</span><br><span class="line">                             != (InstanceKlass*)<span class="literal">NULL</span>))))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// Package private methods always need a new entry to root their own</span></span><br><span class="line">        <span class="comment">// overriding. They may also override other methods.</span></span><br><span class="line">        <span class="keyword">if</span> (!target_method()-&gt;is_package_private()) &#123;</span><br><span class="line">          allocate_new = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkconstraints) &#123;</span><br><span class="line">        <span class="comment">// Override vtable entry if passes loader constraint check</span></span><br><span class="line">        <span class="comment">// if loader constraint checking requested</span></span><br><span class="line">        <span class="comment">// No need to visit his super, since he and his super</span></span><br><span class="line">        <span class="comment">// have already made any needed loader constraints.</span></span><br><span class="line">        <span class="comment">// Since loader constraints are transitive, it is enough</span></span><br><span class="line">        <span class="comment">// to link to the first super, and we get all the others.</span></span><br><span class="line">          <span class="function">Handle <span class="title">super_loader</span><span class="params">(THREAD, super_klass-&gt;class_loader())</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (target_loader() != super_loader()) &#123;</span><br><span class="line">            <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">            Symbol* failed_type_symbol =</span><br><span class="line">              SystemDictionary::check_signature_loaders(signature, target_loader,</span><br><span class="line">                                                        super_loader, <span class="literal">true</span>,</span><br><span class="line">                                                        CHECK_(<span class="literal">false</span>));</span><br><span class="line">            <span class="keyword">if</span> (failed_type_symbol != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">"loader constraint violation: when resolving "</span></span><br><span class="line">                <span class="string">"overridden method \"%s\" the class loader (instance"</span></span><br><span class="line">                <span class="string">" of %s) of the current class, %s, and its superclass loader "</span></span><br><span class="line">                <span class="string">"(instance of %s), have different Class objects for the type "</span></span><br><span class="line">                <span class="string">"%s used in the signature"</span>;</span><br><span class="line">              <span class="keyword">char</span>* sig = target_method()-&gt;name_and_sig_as_C_string();</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span>* loader1 = SystemDictionary::loader_name(target_loader());</span><br><span class="line">              <span class="keyword">char</span>* current = target_klass-&gt;name()-&gt;as_C_string();</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span>* loader2 = SystemDictionary::loader_name(super_loader());</span><br><span class="line">              <span class="keyword">char</span>* failed_type_name = failed_type_symbol-&gt;as_C_string();</span><br><span class="line">              <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(msg) + <span class="built_in">strlen</span>(sig) + <span class="built_in">strlen</span>(loader1) +</span><br><span class="line">                <span class="built_in">strlen</span>(current) + <span class="built_in">strlen</span>(loader2) + <span class="built_in">strlen</span>(failed_type_name);</span><br><span class="line">              <span class="keyword">char</span>* buf = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, <span class="keyword">char</span>, buflen);</span><br><span class="line">              jio_snprintf(buf, buflen, msg, sig, loader1, current, loader2,</span><br><span class="line">                           failed_type_name);</span><br><span class="line">              THROW_MSG_(vmSymbols::java_lang_LinkageError(), buf, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       put_method_at(target_method(), i);<span class="comment">//替换虚函数</span></span><br><span class="line">       <span class="keyword">if</span> (!is_default) &#123;</span><br><span class="line">         target_method()-&gt;set_vtable_index(i);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (def_vtable_indices != <span class="literal">NULL</span>) &#123;</span><br><span class="line">           def_vtable_indices-&gt;at_put(default_index, i);</span><br><span class="line">         &#125;</span><br><span class="line">         assert(super_method-&gt;is_default_method() || super_method-&gt;is_overpass()</span><br><span class="line">                || super_method-&gt;is_abstract(), <span class="string">"default override error"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">        <span class="keyword">if</span> (PrintVtables &amp;&amp; Verbose) &#123;</span><br><span class="line">          <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">          <span class="keyword">char</span>* sig = target_method()-&gt;name_and_sig_as_C_string();</span><br><span class="line">          tty-&gt;print(<span class="string">"overriding with %s::%s index %d, original flags: "</span>,</span><br><span class="line">           target_klass-&gt;internal_name(), sig, i);</span><br><span class="line">           super_method-&gt;access_flags().print_on(tty);</span><br><span class="line">           <span class="keyword">if</span> (super_method-&gt;is_default_method()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"default "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (super_method-&gt;is_overpass()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"overpass"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           tty-&gt;print(<span class="string">"overriders flags: "</span>);</span><br><span class="line">           target_method-&gt;access_flags().print_on(tty);</span><br><span class="line">           <span class="keyword">if</span> (target_method-&gt;is_default_method()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"default "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (target_method-&gt;is_overpass()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"overpass"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           tty-&gt;cr();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*PRODUCT*/</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// allocate_new = true; default. We might override one entry,</span></span><br><span class="line">        <span class="comment">// but not override another. Once we override one, not need new</span></span><br><span class="line">#ifndef PRODUCT</span><br><span class="line">        <span class="keyword">if</span> (PrintVtables &amp;&amp; Verbose) &#123;</span><br><span class="line">          ResourceMark rm(THREAD);</span><br><span class="line">          <span class="keyword">char</span>* sig = target_method()-&gt;name_and_sig_as_C_string();</span><br><span class="line">          tty-&gt;print(<span class="string">"NOT overriding with %s::%s index %d, original flags: "</span>,</span><br><span class="line">           target_klass-&gt;internal_name(), sig,i);</span><br><span class="line">           super_method-&gt;access_flags().print_on(tty);</span><br><span class="line">           <span class="keyword">if</span> (super_method-&gt;is_default_method()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"default "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (super_method-&gt;is_overpass()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"overpass"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           tty-&gt;print(<span class="string">"overriders flags: "</span>);</span><br><span class="line">           target_method-&gt;access_flags().print_on(tty);</span><br><span class="line">           <span class="keyword">if</span> (target_method-&gt;is_default_method()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"default "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (target_method-&gt;is_overpass()) &#123;</span><br><span class="line">             tty-&gt;print(<span class="string">"overpass"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           tty-&gt;cr();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*PRODUCT*/</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> allocate_new;<span class="comment">//如果没有与父类中相同的函数并且满足虚函数特性就返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> klassVtable::put_method_at(Method* m, <span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT</span></span><br><span class="line">  <span class="keyword">if</span> (PrintVtables &amp;&amp; Verbose) &#123;</span><br><span class="line">    ResourceMark rm;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* sig = (m != <span class="literal">NULL</span>) ? m-&gt;name_and_sig_as_C_string() : <span class="string">"&lt;NULL&gt;"</span>;</span><br><span class="line">    tty-&gt;print(<span class="string">"adding %s at index %d, flags: "</span>, sig, index);</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      m-&gt;access_flags().print_on(tty);</span><br><span class="line">      <span class="keyword">if</span> (m-&gt;is_default_method()) &#123;</span><br><span class="line">        tty-&gt;print(<span class="string">"default "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (m-&gt;is_overpass()) &#123;</span><br><span class="line">        tty-&gt;print(<span class="string">"overpass"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tty-&gt;cr();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  table()[index].<span class="built_in">set</span>(m);<span class="comment">// 将函数地址放入虚表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>用上面的Animal文件调试分析，看看vtable内存情况。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Animal  父类</span><br><span class="line">say <span class="number">0x14890250</span> index <span class="number">5</span></span><br><span class="line">table() <span class="number">0x14890520</span>  vtableEntry *</span><br><span class="line">table()[index]  &#123;_method=<span class="number">0x14890250</span> &#125;  vtableEntry</span><br><span class="line"></span><br><span class="line">Dog</span><br><span class="line">say <span class="number">0x148906e0</span> index <span class="number">5</span></span><br><span class="line">table() <span class="number">0x14890920</span> vtableEntry *</span><br><span class="line">table()[index]  &#123;_method=<span class="number">0x14890250</span> &#125;  vtableEntry <span class="comment">//没有替换前与Animal中say函数地址相同</span></span><br><span class="line">table()[index]  &#123;_method=<span class="number">0x148906e0</span> &#125;  vtableEntry <span class="comment">//替换后为Dog的say函数地址</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/14/test/1-5.jpg" alt=""></p>
<p>当Hotspot在运行期加载类Animal时，其 vtable 中将会有一个指针元素指向其say方法在Hotspot内部的内存首地址,当 Hotspot 加载类 Dog 时， 首先类 Dog 完全继承其父类 Animal 的 vtable,因此类 Dog 便也有一个 vtable ，并且 vtable 里有一个指针指向类 Animal 的 say方法的内存地址 。</p>
<p>Hotspot 遍历类 Dog 的所有方法，并发现say方法是 public 的，并且没有被 static 、 final 修饰，于是 HotSpot 去搜索其父类中名称相同、签名也相同的方法,结果发现父类中存在一个完全一样的方法，于是 HotSpot就会将类 Dog 的 vtable 中原本指向类 Animal 的 say方法的内存地址的指针值修改成指向类Dog 自己的say方法所在的内存地址 。</p>
<h3 id="HSDB-查看java-类中的-vtable"><a href="#HSDB-查看java-类中的-vtable" class="headerlink" title="HSDB 查看java 类中的 vtable"></a>HSDB 查看java 类中的 vtable</h3><ol>
<li>下面我们将通过hsdb来验证前面的分析。如前面所述，Java 类在 JVM 内部所对应的类型是 instanceKlass,根据上面一节的分析，我们知道vtable 便分配在 instanceKlass 对象实例的内存末尾 。 instanceKlass 对象实例在X64平台上内存中所占内存大小是 Oxlb8 字节（32位平台上 sizeof(InstanceKlass)=0x00000108），换算成十进制是 440。 根据这个特点，可以使用 HSDB获取到 Java 类所对应的 instanceKlass 在内存中的首地址，然后加上 Oxlb8 ，就得到 vtable 的内存地址 ，如此便可以查看这个内存位置上的 vtable 成员数据 。</li>
</ol>
<p>还是用Animal文件做示例，类 Animal 中仅包含 1 个 Java 方法 ，因此类 Animal 的 vtable长度一共是 6 ，另外 5 个是超类 java.lang.Object 中的5个方法。使用JDB 调试(jdb -XX:-UseCompressedOops Animal),并运行至断点处使程序暂停(stop in Animal.main)-&gt;(run)，jps查看ID,然后使用 HSDB 连接上测试程序(java -classpath “%JAVA_HOME%/lib/sa-jdi.jar” sun.jvm.hotspot.HSDB)，打开 HSDB 的 Tools-&gt;Class Browser 功能，就能看到类 Animal 在 JVM 内部所对应的 instanceKlass 对象实例的内存地址，如图所示 。</p>
<p><img src="/2018/12/14/test/1-6.jpg" alt=""><br><img src="/2018/12/14/test/1-7.jpg" alt=""><br><img src="/2018/12/14/test/1-8.jpg" alt=""></p>
<p>由上图可知，类 Animal 在JVM内部所对应的 instanceKlass的内存首地址是 0x00000000320004a8 ,上一节分析知道vtable 被分配在 instanceKlass的末尾位置，因此 vtable 的内存首地址是 ：</p>
<p>0x00000000320004a8 + Oxlb8 = Ox0000000032000660</p>
<p>这里的 Oxlb8 是 instanceKlass 对象实例所占的内存空间大小 。 得到 vtable 内存地址后，便可以使用 HSDB 的 mem 工具来查看这个地址处的内存数据。单击 HSDB 工具栏上的 Windows-&gt;Console 按钮，打开 HSDB 的终端控制台，按回车键，然后输入“ mem Ox32000660 6”命令，就可以查看从 vtable 内存首地址开始的连续 6 个双字内容，如下所示：</p>
<p><img src="/2018/12/14/test/1-9.jpg" alt=""><br><img src="/2018/12/14/test/1-10.jpg" alt=""></p>
<p>在 64 位平台上， 一个指针占 8 字节 ，而 vtable 里的每一个成员元素都是一个指针，因此这里 mem 所输出 的 6 行 ，正好是类 Animal 的 vtable 里的 6 个方法指针，每一个指针指向 l 个方法在内存中的位置。 类 A 的 vtable 总个数是 6 ，其中前面 5 个是基类 java.lang.Object 中的 5 个方法的指针 。上面 mem 命令所输出的第 6 行的指针， 一定就是指向类 Animal 自己的say方法的内存地址 。 使用HSDB 查看类 A 的方法的内存地址,如图中所示，地址刚好对应得上。其它的类也可以用同样的方式分析。</p>
<h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04: 总结"></a>0x04: 总结</h3><p>前面对jvm 的vtable 进行了研究和验证，再总结下特点：</p>
<ol>
<li><p>vtable 分配在 instanceKlass对象实例的内存末尾 。</p>
</li>
<li><p>其实vtable可以看作是一个数组，数组中的每一项成员元素都是一个指针，指针指向 Java 方法在 JVM 内部所对应的 method 实例对象的内存首地址 。</p>
</li>
<li><p>vtable是 Java 实现面向对象的多态性的机制，如果一个 Java 方法可以被继承和重写， 则最终通过 put_method_at函数将方法地址替换,完成 Java 方法的动态绑定。</p>
</li>
</ol>
<p>4.Java 子类会继承父类的 vtable，Java 中所有类都继承自 java.lang.Object, java .lang.Object 中有 5 个虚方法（可被继承和重写）：</p>
<p>void finalize()</p>
<p>boolean equals(Object)</p>
<p>String toString()</p>
<p>int hashCode()</p>
<p>Object clone()</p>
<p>因此，如果一个 Java 类中不声明任何方法，则其 vtalbe 的长度默认为 5 。</p>
<p>5.Java 类中不是每一个 Java 方法的内存地址都会保存到 vtable 表中，只有当 Java子类中声明的 Java 方法是 public 或者 protected 的，且没有 final 、 static 修饰，并且 Java 子类中的方法并非对父类方法的重写时， JVM 才会在 vtable 表中为该方法增加一个引用 。</p>
<p>6.如果 Java 子类某个方法重写了父类方法，则子类的vtable 中原本对父类方法的指针会被替换成子类对应的方法指针，调用put_method_at函数替换vtable中对应的方法指针。</p>
<p>以上只是个人学习的一点总结，水平能力有限，如果有不对的地方还请多多指教，万分感谢。</p>
<p>More info: <a href="https://bbs.pediy.com/thread-221160.htm" target="_blank" rel="noopener">原文链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/14/test/" data-id="cjpnq8vd800010ovohi6vhpju" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/14/楚轩/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          楚轩
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/14/楚轩/">楚轩</a>
          </li>
        
          <li>
            <a href="/2018/12/14/test/">从jvm虚拟机角度看Java多态 -&gt;（重写override）的实现原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 楚轩<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>